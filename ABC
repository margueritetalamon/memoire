
#Fonction qui permet de calculer la mise à jour de la loi de Dirichlet pour les p
rdirich_inv<-function(n_left,prob,index,delta,K,p){
  prob_temp<-prob[index,]
  z_temp<-rgamma(n_left,sum(delta),1)
  b_temp<-matrix(rbeta(K*n_left,p*delta,(1-p)*delta),n_left)
  eta_temp<-matrix(rgamma(K*n_left,(1-p)*delta,1),n_left)
  prob_prop<-z_temp*b_temp*prob_temp+eta_temp
  return(prob_prop/rowSums(prob_prop))
}
#Fonction permettant de traiter le label switching
label_switching<-function(mu,sig,prob){
  #Calcul des valeurs représentatives
  mu_ref<-rowMeans(pnorm(mu,mean(mu),sd(mu)))
  sig_ref<-sqrt(rowMeans(pnorm(sig^2,mean(sig^2),sd(sig^2))))
  prob_ref<-rowMeans(pnorm(prob,mean(prob),sd(prob)))
  #Selection de la variable qui présente le plus grand écart entre deux de ses valeurs représentatives
  i<-which.max(c(max(dist(mu_ref)), max(dist(sig_ref)), max(dist(prob_ref))))
  
  
  if (i==1){
    ord<-order(mu)
  }
  if (i==2){
    ord<-order(sig)
  }
  if (i==3){
    ord<-order(prob)
  }
  #On retourne les paramètres triés selon l'odre du paramètre séléctionné
  return(list(mu=matrix(mu[ord],nrow=nrow(mu)),
              sig=matrix(sig[ord],nrow=nrow(sig)),
              prob=matrix(prob[ord],nrow=nrow(prob))))
}
#Permet de calculer le produit des colonnes d'une matrice
colprod<-function(x){
  M<-rep(0,nrow(x))
  for (i in 1:nrow(x)){
    M[i]<-prod(x[i,])
  }
  return(M)
}

#Fonction qui calcule la mise a jour des poids W
weight_t<-function(mu_t,sig_t,W,mu,sig,tau_mu,tau_sig,
                   xbar=rep(mean(x),K),
                   v=rep(20,K),
                   s_k=rep(var(x),K),
                   l=rep(1,K)){
  sd_mu<- sqrt(rinvgamma(K,0.5*v,s_k))/l
  #Calcul du dénominateur de la formule
  q<-as.matrix(apply(mu_t,1,dmnorm,x=mu,varcov=tau_mu)*apply(sig_t,1,dtmvnorm,x=sig,sigma=tau_sig,lower=c(0,0)))
  M<-t(as.matrix(W))
  L_t<-M%*%q
  #Calcul du numérateur de la formule
  num_t<-colprod(t(apply(mu_t,1,dnorm,xbar,sd_mu)*apply(sig_t^2,1,dinvgamma,0.5*v,s_k)))
  return(as.vector(num_t/L_t))
}



#Algorithme ABC pour un modèle de mélange gaussien à K composantes, 
#Prior pour p : dirichlet(delta)
#Prior pour mu: N(xbar,sig/l)
#Prior pour sig : InvGamma(0.5*v,s_k)
abc<-function(n_iter,N_init,N,K,n,x,
             q=0.5,
             p=0.5,
             xbar=rep(mean(x),K),
             l=rep(1,K),
             v=rep(20,K),
             s_k=rep(var(x),K),
             delta=rep(0.5,K)){
 


  #Initialisation
  #Calcul de la densité estimé de l'échantillon observé
  f_obs<-densityfun(x)
  
  rho<-rep(0,N_init)
  prob<-rdirichlet(N_init,delta)
  sig<-matrix(sqrt(rinvgamma(K*N_init,0.5*v,s_k)),nrow=N_init)
  mu<-t(xbar + matrix(rnorm(K*N_init),K)*t(sig)/l)
  
  #Calcul de la distance de hellinger 
  rho<-foreach (i= seq_len(N_init), .combine =c) %dopar% { 
  #Calcul de la densité de l'échantillon simulé
    f_prop <- statip::densityfun(gen3_mix(100,prob[i,],mu[i,],sig[i,]))
    cubature::cubintegrate(function(x){
      (sqrt(f_obs(x))- sqrt(f_prop(x)))^2
    }, -Inf, Inf)$integral
  }
  
  rho<-sqrt(0.5*rho)
  
  #On garde les N composantes correspondant aux N plus petites distances
  keep<-order(rho)[seq_len(N)]
  rho<-rho[keep]
  mu<-mu[keep,]
  sig<-sig[keep,]
  prob<-prob[keep,]
  W<-rep(1/N,N)
  
  #Traiter le problème du Label Switching
  switch<-label_switching(mu,sig,prob)
  mu<-switch$mu
  sig<-switch$sig
  prob<-switch$prob

  
  rho_t<-rep(0,N)
  
  prob_t<-matrix(0,N,K)
  mu_t<-matrix(0,N,K)
  sig_t<-matrix(0,N,K)
  
  for (t in 2:n_iter){
    eps<-quantile(rho,q)
    tau_mu<-2*cov(mu)
    tau_sig_2<-2*cov(sig^2)
    n_left<-N
    #Simulation N nouveaux échantillons, n_left est le nombre d'échantillons manquants
    while(n_left>0){
      #On séléctionne n_left composantes parmis les N composantes précédentes
      index<-sample(1:N,n_left,TRUE,W/sum(W))
      #Mise à jour les n_left paramètres correspondants 
      prob_prop<-rdirich_inv(n_left,prob,index,delta,K,p)
      mu_prop<-mu[index,]+rtmvnorm(n_left,rep(0,K),tau_mu)
      sig_prop<-matrix(1,n_left,K)
      sig_prop<-sig[index,]^2+rtmvnorm(n_left,rep(0,K),tau_sig_2,lower=rep(0,K))
      #Calcul des distances de Hellignger pour ses composantes
      rho_prop<-foreach (i= seq_len(n_left), .combine =c) %dopar% { 
        f_prop <- statip::densityfun(gen3_mix(100,prob_prop[i,],mu_prop[i,],sig_prop[i,]))
        cubature::cubintegrate(function(x){
          (sqrt(f_obs(x))- sqrt(f_prop(x)))^2
        }, -Inf, Inf)$integral
      }
      rho_prop<-sqrt(0.5*rho_prop)
      #On retient que les composantes pour lesquels la distance est inférieure au seuil de tolérance
      keep<-(rho_prop <= eps)
      batch <- (N - n_left) + seq_len(sum(keep))
      #On remplie la matrice des échantillons 
      rho_t[batch]<-rho_prop[keep]
      mu_t[batch,]<-mu_prop[keep,]
      sig_t[batch,]<-sig_prop[keep,]
      prob_t[batch,]<-prob_prop[keep,]
      
      
      
      n_left<-n_left - sum(keep)
      
    }
    #Mise à jour du vecteur des probabilités
    W<-weight_t(mu_t,sig_t,W,mu,sig,tau_mu,tau_sig_2)
    
    #Traiter le label switching
    switch_t<-label_switching(mu_t,sig_t,prob_t)
    
    mu<-switch_t$mu
    sig<-switch_t$sig
    prob<-switch_t$prob
    
  }
  return(list(prob=prob,mu=mu,sig=sig))
}

